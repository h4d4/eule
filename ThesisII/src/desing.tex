\label{ch:desing}
\chapter{Diseño e Implementación}

\section{Limitaciones técnicas para implementar el prototipo}
-\textit{Características del lenguaje Java no soportadas por jif:}\newline
si bien, jif posibilita la evaluación de políticas de confidencialidad
e integridad para aplicativos implementados en Java, mediante anotaciones que
extienden el lenguaje, el manual de referencia de jif es claro en precisar
características del lenguaje java no soportadas, estas son: nested
classes(clases que son definidas dentro de otras clases), initializer
blocks(bloques de código declarados dentro de la clase pero sin pertenecer a
ningún método, dependiendo de si se trata de static initialization blocks, son
lo primero que se ejecuta una vez se carga la clase, o si se trata de instance
initialization blocks, se ejecutan cada vez que se crea una instancia de la
clase) y threads.\newline 
Partiendo de estas precisiones, aplicaciones Android que presenten tales
características son excluidas del grupo de aplicaciones a analizar mediante la
herramienta propuesta.\newline 
Adicional a las limitaciones propias de jif frente al lenguaje Java, tras
experimentar la anotación manual de una serie de aplicaciones Android, se
identifican varias limitaciones técnicas para la anotación de código
perteneciente a la API de Android. Entre las limitaciones identificadas están:\newline 
- \textit{Sintaxis for-each:}\newline
- \textit{Símbolo para sobreescritura de métodos:}\newline
jif no reconoce el símbolo de anotación @, utilizado para indicar que un método
es sobreescrito(@Override). Según el componente que se esté implementando, la
construcción de aplicaciones Android requiere la sobreescritura de métodos, así
cuando se define una actividad, métodos del ciclo de vida como onCreate deben
ser sobreescritos. La dificultad que se presenta está en que jif no reconoce el
símbolo de anotación, y no en que jif no soporte la anotación de métodos, puesto
que las pruebas realizas señalan que jif soporta tal característica. Ante esto,
la solución que se adopta para la implementación del prototipo es comentar las
líneas del programa que contengan @Override.\newline 
- \textit{Casting entre tipos EditText y View:}\newline
el framework de Android cuenta con diferentes clases para manejar las interfaces
graficas que presenta al usuario, entre las cuales se encuentran EditText y
View. View es la clase principal para la creación de widgets, necesarios para la
implementación de componentes interactivos en las interfaces de usuario.
EditText permite adicionar campos de texto editables en interfaces UI. El
casting entre los tipos de datos que representan ambas clases, suele usarse
cuando la aplicación debe procesar datos provenientes de campos en las
interfaces del usuario, por ejemplo como se observa a continuación:
\begin{lstlisting}
EditText editPassword = (EditText)findViewById(R.id.password);
String password = editPassword.getText().toString();
\end{lstlisting}
la interfaz de usuario(que es de tipo View) contiene un campo R.id.password, y
para manipular la información que almacena, debe ser de tipo EditText, siendo
necesario un casting de View a tipo EditText. La dificultad que se presenta con
este tipo de casting es que para el sistema de anotaciones de jif no es válido.
Una forma de superar esta limitación es asingar el valor contenido en tipos
EditText, a variables tipo String, de modo que no se requiera el casting
descrito.\newline
- \textit{Clase nested R:}\newline
el framework de Android utiliza identificadores para hacer referencia a recursos
utilizados por la aplicación, recursos como strings, widgets y layouts, tales
identificadores son autogenerados en la clase R.java, allí cada recurso es
descrito como una clase individual. Al tratarse de una clase nested, la clase R
no puede ser anotada con jif. Esto se soluciona definiendo una clase R que
contenga los recursos definidos como variables y no como clases.\newline
- \textit{Sources y Sinks:}\newline
en el diseño inicial de la solución, se
planteó utilizar SuSi para clasificar los sources y sinks en las aplicaciones a analizar, sin embargo,
partir del extenso conjunto de sources y sinks que SuSi clasifica para la API de
Android, implica una mayor complejidad en el análisis, puesto que, en un
aplicativo todo el código que le conforma puede hacer parte de sources o de
sinks. Adicional a lo complejo que se puede tornar el análisis, los sources y
sinks a considerar dependen de la política de seguridad a evaluar, en ese orden
de ideas, partiendo de la política de seguridad que se defina, del listado
proveído por SuSi, se selecciona un subconjunto específico de sources y sinks.

Además de las limitaciones descritas anteriormente, para las cuales se propuso
una solución, se identifican otras en que la solución sobrepasa los límites de
la presente investigación, puesto que corresponden a sintaxis no aceptada por el
compilador de jif.\newline

- \textit{Sintaxis para hashmaps:}\newline 
- \textit{Sintaxis para listas:}\newline 
- \textit{Paso de statements dentro de los argumentos de un método
(\{\}):}\newline
- \textit{No soporte para LinkedLIst:}\newline

\section{Diseño de la solución} 
\subsection{Definición de la política de seguridad}
Detectar si una aplicación Android(perteneciente al conjunto evaluable) presenta
flujos de información entre, información con nivel de seguridad alto e
información con nivel de seguridad bajo.\newline 
Detectando fugas de información catalogada con nivel de seguridad alto, vía:
canales creados durante el control de flujo del programa(flujos implícitos),
mensajes de texto y mensajes de Log.\newline 

\subsection{Consideraciones para verificar el cumplimiento de la política
mediante Jif} 
\textit{Versión de la API de Android:}\newline
los experimentos previos a la implementación del prototipo y, la implementación
del mismo se realiza partiendo de la versión Android 4.2.2(API Level 17).

\textit{Versión del compilador de jif:}\newline
se parte de la versión 3.4.2 del compilador de jif, para llevar a cabo tanto los
experimentos previos como el análisis de las aplicaciones anotadas por el
prototipo.

\textit{Diferencia entre una aplicación Android y una aplicación Java
convencional:}\newline 
En esencia, una aplicación Android es una aplicación Java con interfaces
descritas en XML, que para ser ejecutada necesita del framework de Android,
porque este le provee acceso al hardware del dispositivo y funcionalidades del
sistema.\newline 
Por otro lado, jif permite hacer seguimiento al flujo de información de una
aplicación Java, extendiendo el lenguaje mediante labels de seguridad.\newline
Para analizar flujo de información de una aplicación Android mediante
jif, es importante mencionar que mientras una aplicación Java convencional
cuenta con un único método como punto de entrada para iniciar su ejecución(el
método main de la clase principal); una aplicación Android puede tener más de un
punto de entrada, generados a partir de los diferentes tipos de componentes que
la pueden integrar(Activity, Service, Content Provider y Broadcast
Receiver). La necesidad de interacción del usuario para activar tales puntos de
entrada varía acorde al tipo de componente, así, en el caso de componentes tipo
Activity su ejecución sólo inicia hasta que el usuario interactúe con la
actividad, y para ello cuenta con el método OnCreate. De otro modo, componentes
tipo Service y Broadcast Receiver, inician su ejecución a través de los métodos
OnStartCommand y OnReceive, respectivamente, sin necesidad de interacción del
usuario.\newline 
{ \color{black} {Teniendo en cuenta lo anterior, se asume que la aplicación a
evaluar tiene un único punto de entrada, que depende del tipo de componente que
implemente.} }

\textit{Información considerada con nivel de seguridad alto:}\newline
Para verificar el cumplimiento de la política de seguridad a evaluar se parte de
un conjunto de sources, caracterizados por dar a conocer información del
usuario, considerada como privada o sensible. Los métodos que integran el
conjunto de sources son: getDeviceId, getSimSerialNumber, findViewById,
getLatitude, getLongitude y getSubscriberId. Adicional a estos métodos, se
incluye el campo EditText, si y sólo si, es de tipo textPassword, es decir, un
campo que almacena contraseñas.

\textit{Canales que muestran información con nivel de seguridad bajo}\newline
La información enviada a través de mensajes de texto y la información conocida
tanto a través de mensajes de Log, como a través de canales generados por el
control de flujo del programa, tiene en común que debe poder ser conocida por
terceros. En consecuencia, se considera que estos canales deben dar a conocer
información con nivel de seguridad bajo.\newline
En el caso de mensajes de texto y mensajes de Log, se hace referencia
específicamente a las clases Log y SmsManager de la API de Android.

\textit{Evaluación del flujo de información:}\newline
Para evaluar el flujo de información, se tienen en cuenta todos los métodos
definidos dentro de la clase, se asume que todos los métodos son invocados, esto
con el fin de evitar omisiones de flujo de información a través de los canales
previamente mencionados.

\textit{Estructura de trabajo en JIF:}\newline


\subsection{Pasos para el diseño de la solución}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=12cm]{desingSol-steps1-2.jpg}
	\end{center}
	\caption{Pasos para el diseño de la solución.}
	\label{fig:desingSol-steps1-2}
\end{figure}

-Paso uno: hacer que jif reconozca determinadas clases de la API de
Android.\newline 
Adicional al mecanismo de anotación que se maneja en jif, en que para hacer
análisis al flujo de información de un programa java, se debe implementar la
versión del respectivo programa para jif. También es posible adicionar clases
Java ya existentes, utilizando signaturas nativas para que el compilador jif las
reconozca, esto es: generando una versión jif de la clase java, donde se
declaran constructores y cuerpo de los métodos a utilizar de la clase fuente
java.\newline
Para el presente trabajo se utilizan ambas opciones de anotación. El criterio
para decidir que se anota de una u otra forma, depende de lo que represente la
clase Android para verificar la política de seguridad establecida. Las clases
Log y SmsManager, que representan canales para conocer información, son anotadas
de forma no nativa. La opción de anotación nativa se utiliza para librerías
Android, por ejemplo la clase TelephonyManager necesaria para utilizar el método
getDeviceId.\newline A continuación se ilustran las clases anotadas.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=14cm]{desingSol-step1-details.jpg}
	\end{center}
	\caption{Diseño de la solución paso 1. Ilustra las clases especificas de la
	clase de Android, anotadas manualmente.}
	\label{fig:desingSol-step1}
\end{figure}

Los métodos de las clases Activity, Service y BroadcastReceiver, son métodos
que se pueden sobreescribir, todo programa Android que extienda de tales clases
debe poder utilizarlos.

-Paso dos: 
Definir Autoridades y forma de anotación del programa Android a analizar.
Una clase Android tendrá una Autoridad máxima(un principal), en este caso Alice,
así que, información con nivel de seguridad alto deberá pertenecer a dicha
autoridad.\newline
Jif hace seguimiento al flujo de información del programa, asociando un label
de seguridad al program counter de cada sentencia y expresión del programa,
program counter(pc) label. Este pc se ve afectado por el label
de seguridad que se especifique en la declaración de variables y
métodos.\newline 
La sintaxis para anotación de variables es: \newline 
\emph{ type\{L\} varName; } \newline donde type especifica el tipo de dato que
almacena la variable, \{L\} el label de seguridad  para especificar quien es el
dueño de la variable, y name, el respectivo nombre de la variable.\newline
Definición de arrays:\newline
en jif un array cuenta con dos labels de seguridad, Base Label(BL) y Size
Label(SL). BL indica el nivel de seguridad de los elementos que almacena el
array, controlando quien puede conocer la información del mismo. SL especifica
quienes pueden conocer la número de elementos almacenados.\newline
Un método se escribe de la forma:\newline
\emph{ type \{RTL\} methodName \{BL\} (arg1\{AL\},,, argn\{AL\}) :\{EL\}
}\newline RTL, Return Type Label, indica el label de seguridad con que
queda el tipo de dato devuelto por el método.\newline 
BL begin label, representa el máximo nivel se seguridad del pc label desde donde
se invoca el método, de este modo, el program counter label desde donde
se invoca el método debe ser menor o igual de restrictivo que el BL del
método.\newline 
AL argument label, indica el máximo nivel de seguridad  para los argumentos con
que se llama el método, así, los labels de los argumentos con que se invoca el
método deben ser menor o igual de restrictivos que los AL con que han
definido el método.\newline
EL end label, indica el pc label en el punto de terminación del método, y
representa la información que puede ser conocida.\newline
Cuando un label no es especificado, Jif define unos por defecto. En el caso de
RTL, jif hace un join entre los diferentes AL con que ha sido definido el
método.\newline

Partiendo de que Jif se fundamenta en labels de seguridad para hacer seguimiento
al flujo de información del programa, es necesario definir los labels a
anotar para métodos y variables del programa.\newline
En el caso de variables con nivel de seguridad  alto, la anotación debe
ser:\newline
\emph{ type\{Alice:\} varName; }\newline
Para el resto de variables, entran a jugar las anotaciones definidas por Jif
acorde al contexto donde están definidas.

Ahora en el caso de los métodos, la anotación varía acorde a si el método debe
influenciar(acceder, modificar) o no, información anotada con nivel de seguridad
alto.
Partiendo de lo anterior, se define un algoritmo de anotación que se condensa en
un generador de anotaciones.\newline 
- Descripción criterios de anotación:\newline
\textit{Definición A:} anotación de variables con nivel de seguridad alto:
\newline 
modifier type\{Alice:\} varName;\newline 
\textit{Definición B:} métodos que se sobreescriben. El sistema de anotaciones
de jif exige que el nivel de seguridad del método desde donde se invoca la
sobreescritura de un método, no debe ser menos restrictivo que el método a
sobreescribir, y como se mencionó al final del paso uno, los métodos a
sobreescribir deben poder ser invocados desde todo programa Android, siguiendo
con este principio, y buscando que jif no limite el flujo de información, estos
métodos deben ser anotados con BL público(\{\}).\newline 
\textit{Definición C:} anotación de métodos con sources\newline
Los labels para la definición del método(BL, EL, AL )se anotan de la
siguiente manera:\newline modifier type
nameMethod\textit{\{Alice:\}} type\textit{\{Alice:\}}
( arg1,.....type\textit{\{Alice:\}}argn ) \{\}\newline Si dentro del método se
definen arrays, sus respectivos BL y SL, deben ser anotados así: modifier type\{Alice:\}[ ]\{Alice:\}\newline
\textit{Definición D:} anotación de métodos que no reciben información del
source. 
nameMethod\textit{\{\}}(
type\textit{\{Alice:\}}arg1,.....type\textit{\{Alice:\}}argn ) \{\}\newline
- Pasos:\newline
(1) Identificar sources de la clase. Si se encuentran sources continuar con
los pasos (2) a (4), sino, continuar con paso (2) y aplicar definiciones B y
D.\newline
(2) Identificar el total de métodos de la clase.\newline
(3) Del total de métodos listar los que son invocados con el source.\newline
(4) Del total de métodos listar los que no son invocados con el source.\newline
(5) Aplicar definición C a listado del paso(3).\newline
(6) Aplicar definición D a listado del paso (4).\newline
(7) Aplicar definición B. \newline
(8) Aplicar definición A a listado del paso (1).

\subsection{Descripción implementación prototipo}
clases, qué aporta cada clase.

