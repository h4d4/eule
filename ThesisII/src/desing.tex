\label{ch:desing}
\chapter{Diseño e Implementación}

\section{Limitaciones técnicas para implementar el prototipo}
Si bien, Jif posibilita la evaluación de políticas de confidencialidad e
integridad en aplicativos Java, mediante anotaciones que extienden el lenguaje
Java. Es necesario precisar que Jif no soporta las siguientes características
del lenguaje Java: nested classes, initializer blocks y threads.\newline
En consecuencia aplicaciones Android que presenten tales características son
exclidas del grupo de aplicaciones a analizar mediante la herramienta
propuesta.\newline
Adicional a las limitaciones propias de Jif frente al lenguaje Java, tras
experimentar la anotación manual de una serie de aplicaciones Android, se
identifican varias limitaciones técnicas para la anotación de código
perteneciente a la API de Android. Entre las limitaciones identificadas
están:\newline 
- Sources y Sinks - JIF no reconoce el simbolo de anotación @,
utilizado para la sobreescritura de varios métodos de la API de Android. \newline 
- clase Context 
- Casting de tipo edidtext y view
- No se puede reconocer la clase nested R 

- API para la que se ha implementado el prototipo


\section{Diseño de la solución} 
\subsection{Definición de la política de seguridad}
Detectar si una aplicación Android(perteneciente al conjunto evaluable) presenta
flujos de información entre, información con nivel de seguridad alto e
información con nivel de seguridad bajo.\newline 
Detectando fugas de información catalogada con nivel de seguridad alto, vía:
canales creados durante el control de flujo del programa(flujos implícitos),
mensajes de texto y mensajes de Log.\newline 

\subsection{Consideraciones para verificar el cumplimiento de la política
mediante Jif} 
\textit{Diferencia entre una aplicación Android y una aplicación Java
convencional:}\newline 
En esencia, una aplicación Android es una aplicación Java con interfaces
descritas en XML, que para ser ejecutada necesita del framework de Android,
porque este le provee acceso al hardware del dispositivo y funcionalidades del
sistema.\newline 
Por otro lado, jif permite hacer seguimiento al flujo de información de una
aplicación Java, extendiendo el lenguaje mediante labels de seguridad.\newline
Para analizar flujo de información de una aplicación Android mediante
jif, es importante mencionar que mientras una aplicación Java convencional
cuenta con un único método como punto de entrada para iniciar su ejecución(el
método main de la clase principal); una aplicación Android puede tener más de un
punto de entrada, generados a partir de los diferentes tipos de componentes que
la pueden integrar(Activity, Service, Content Provider y Broadcast
Receiver). La necesidad de interacción del usuario para activar tales puntos de
entrada varía acorde al tipo de componente, así, en el caso de componentes tipo
Activity su ejecución sólo inicia hasta que el usuario interactúe con la
actividad, y para ello cuenta con el método OnCreate. De otro modo, componentes
tipo Service y Broadcast Receiver, inician su ejecución a través de los métodos
OnStartCommand y OnReceive, respectivamente, sin necesidad de interacción del
usuario.\newline 
{ \color{black} {Teniendo en cuenta lo anterior, se asume que la aplicación a
evaluar tiene un único punto de entrada, que depende del tipo de componente que
implemente.} }

\textit{Información considerada con nivel de seguridad alto:}\newline
Para verificar el cumplimiento de la política de seguridad a evaluar se parte de
un conjunto de sources, caracterizados por dar a conocer información del
usuario, considerada como privada o sensible. Los métodos que integran el
conjunto de sources son: getDeviceId, getSimSerialNumber, findViewById,
getLatitude, getLongitude y getSubscriberId. Adicional a estos métodos, se
incluye el campo EditText, si y sólo si, es de tipo textPassword, es decir, un
campo que almacena contraseñas.

\textit{Canales que muestran información con nivel de seguridad bajo}\newline
La información enviada a través de mensajes de texto y la información conocida
tanto a través de mensajes de Log, como a través de canales generados por el
control de flujo del programa, tiene en común que debe poder ser conocida por
terceros. En consecuencia, se considera que estos canales deben dar a conocer
información con nivel de seguridad bajo.\newline
En el caso de mensajes de texto y mensajes de Log, se hace referencia
específicamente a las clases Log y SmsManager de la API de Android.\newline

\textit{Evaluación del flujo de información:}\newline
Para evaluar el flujo de información, se tienen en cuenta todos los métodos
definidos dentro de la clase, se asume que todos los métodos son invocados, esto
con el fin de evitar omisiones de flujo de información a través de los canales
previamente mencionados.


\textit{Pasos para el diseño de la solución:}\newline

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=12cm]{desingSol-steps1-2.jpg}
	\end{center}
	\caption{Pasos para el diseño de la solución.}
	\label{fig:desingSol-steps1-2}
\end{figure}

-Paso uno: hacer que jif reconozca determinadas clases de la API de
Android.\newline 
Adicional al mecanismo de anotación que se maneja en jif, en que para hacer
análisis al flujo de información de un programa java, se debe implementar la
versión del respectivo programa para jif. También es posible adicionar clases
Java ya existentes, utilizando signaturas nativas para que el compilador jif las
reconozca, esto es: generando una versión jif de la clase java, donde se
declaran constructores y cuerpo de los métodos a utilizar de la clase fuente
java.\newline
Para el presente trabajo se utilizan ambas opciones de anotación. El criterio
para decidir que se anota de una u otra forma, depende de lo que represente la
clase Android para verificar la política de seguridad establecida. Las clases
Log y SmsManager, que representan canales para conocer información, son anotadas
de forma no nativa. La opción de anotación nativa se utiliza para librerías
Android, por ejemplo la clase TelephonyManager necesaria para utilizar el método
getDeviceId.\newline A continuación se ilustran las clases anotadas.

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=14cm]{desingSol-step1-details.jpg}
	\end{center}
	\caption{Diseño de la solución paso 1. Ilustra las clases especificas de la
	clase de Android, anotadas manualmente.}
	\label{fig:desingSol-step1}
\end{figure}

Los métodos de las clases Activity, Service y BroadcastReceiver, son métodos
que se pueden sobreescribir, todo programa Android que extienda de tales clases
debe poder utilizarlos.

-Paso dos: 
Definir Autoridades y forma de anotación del programa Android a analizar.
Una clase Android tendrá una Autoridad máxima(un principal), en este caso Alice,
así que, información con nivel de seguridad alto deberá pertenecer a dicha
autoridad.\newline
Jif hace seguimiento al flujo de información del programa, asociando un label
de seguridad al program counter de cada sentencia y expresión del programa,
program counter(pc) label. Este pc se ve afectado por el label
de seguridad que se especifique en la declaración de variables y
métodos.\newline 
La sintaxis para anotación de variables es: \newline 
\emph{ type\{L\} varName; } \newline donde type especifica el tipo de dato que
almacena la variable, \{L\} el label de seguridad  para especificar quien es el
dueño de la variable, y name, el respectivo nombre de la variable.\newline
Definición de arrays:\newline
en jif un array cuenta con dos labels de seguridad, Base Label(BL) y Size
Label(SL). BL indica el nivel de seguridad de los elementos que almacena el
array, controlando quien puede conocer la información del mismo. SL especifica
quienes pueden conocer la número de elementos almacenados.\newline
Un método se escribe de la forma:\newline
\emph{ type \{RTL\} methodName \{BL\} (arg1\{AL\},,, argn\{AL\}) :\{EL\}
}\newline RTL, Return Type Label, indica el label de seguridad con que
queda el tipo de dato devuelto por el método.\newline 
BL begin label, representa el máximo nivel se seguridad del pc label desde donde
se invoca el método, de este modo, el program counter label desde donde
se invoca el método debe ser menor o igual de restrictivo que el BL del
método.\newline 
AL argument label, indica el máximo nivel de seguridad  para los argumentos con
que se llama el método, así, los labels de los argumentos con que se invoca el
método deben ser menor o igual de restrictivos que los AL con que han
definido el método.\newline
EL end label, indica el pc label en el punto de terminación del método, y
representa la información que puede ser conocida.\newline
Cuando un label no es especificado, Jif define unos por defecto. En el caso de
RTL, jif hace un join entre los diferentes AL con que ha sido definido el
método.\newline

Partiendo de que Jif se fundamenta en labels de seguridad para hacer seguimiento
al flujo de información del programa, es necesario definir los labels a
anotar para métodos y variables del programa.\newline
En el caso de variables con nivel de seguridad  alto, la anotación debe
ser:\newline
\emph{ type\{Alice:\} varName; }\newline
Para el resto de variables, entran a jugar las anotaciones definidas por Jif
acorde al contexto donde están definidas.

Ahora en el caso de los métodos, la anotación varía acorde a si el método debe
influenciar(acceder, modificar) o no, información anotada con nivel de seguridad
alto.
Partiendo de lo anterior, se define un algoritmo de anotación que se condensa en
un generador de anotaciones.\newline 
- Descripción criterios de anotación:\newline
\textit{Definición A:} anotación de variables con nivel de seguridad alto:
\newline 
modifier type\{Alice:\} varName;\newline 
\textit{Definición B:} métodos que se sobreescriben. El sistema de anotaciones
de jif exige que el nivel de seguridad del método desde donde se invoca la
sobreescritura de un método, no debe ser menos restrictivo que el método a
sobreescribir, y como se mencionó al final del paso uno, los métodos a
sobreescribir deben poder ser invocados desde todo programa Android, siguiendo
con este principio, y buscando que jif no limite el flujo de información, estos
métodos deben ser anotados con BL público(\{\}).\newline 
\textit{Definición C:} anotación de métodos con sources\newline
Los labels para la definición del método(BL, EL, AL )se anotan de la
siguiente manera:\newline modifier type
nameMethod\textit{\{Alice:\}} type\textit{\{Alice:\}}
( arg1,.....type\textit{\{Alice:\}}argn ) \{\}\newline Si dentro del método se
definen arrays, sus respectivos BL y SL, deben ser anotados así: modifier type\{Alice:\}[ ]\{Alice:\}\newline
\textit{Definición D:} anotación de métodos que no reciben información del
source. 
nameMethod\textit{\{\}}(
type\textit{\{Alice:\}}arg1,.....type\textit{\{Alice:\}}argn ) \{\}\newline
- Pasos:\newline
(1) Identificar sources de la clase. Si se encuentran sources continuar con
los pasos (2) a (4), sino, continuar con paso (2) y aplicar definiciones B y
D.\newline
(2) Identificar el total de métodos de la clase.\newline
(3) Del total de métodos listar los que son invocados con el source.\newline
(4) Del total de métodos listar los que no son invocados con el source.\newline
(5) Aplicar definición C a listado del paso(3).\newline
(6) Aplicar definición D a listado del paso (4).\newline
(7) Aplicar definición B. \newline
(8) Aplicar definición A a listado del paso (1).



