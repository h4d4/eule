\label{ch:evaluacion}
\chapter{Evaluación}
Ventajas y limitaciones de la solución.\newline 
Si aplica, evaluación de desempeño.  \newline 
Si aplica, evaluación de usabilidad.  
Hay otras soluciones similares? \newline 
Cuáles son las diferencias y las ventajas y desventajas con respecto a esas soluciones.

\section{Consideraciones de evaluación}
No se consideran flujos de información vía interAppComunicación. Por ejemplo,
varias aplicaciones que se comunican entre sí.

\section{Evaluación conjunto de aplicaciones}
Para la evaluación del prototipo se toma un grupo de testcases de DroidBech, el
benchmark de FlowDroid, evaluables frente a la política de seguridad
establecida.\newline 
Se considera con nivel de seguridad alto, variables y métodos que almacenan y
modifican(respectivamente), información catalogada como privada(Sources).\newline 
Se considera con nivel de seguridad bajo, canales para envío de mensajes,
muestra de logs y canales creados durante el control de flujo del programa.\newline 
La tabla \ref{tb:muestra-descripApps} describe parte del grupo de testcases a
evaluar. En los casos en que se requiere, se precisan observaciones entre los
resultados de evaluación esperados para la técnica de análisis utilizada por
FlowDroid y la técnica de análisis propuesta en el presente trabajo.\newline 
La descripción para el grupo completo de testcases está en los anexos\ref{sec:testcases}.

\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Descripción aplicaciones de prueba}
\label{tb:muestra-descripApps}
\begin{tabular}{|p{13cm}|p{1cm}|}
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_DirectLeak1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{mrg} tiene un nivel de seguridad alto,
	almacena información retornada por el método source \textit{getDeviceId}. Se
	genera flujo de información directo entre información con nivel de seguridad alto e
	información con nivel de seguridad bajo, al enviar como parámetro del método
	\textit{sendTextMessage}, información de la variable \textit{mrg}. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_LogNoLeak}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	El caso de prueba no presenta información con niveles de seguridad alto. Se
	presentan flujos de información entre información con el mismo nivel de
	seguridad, en este caso bajo, lo cual es permitido. & 0 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ArraysAndLists\_ArrayAccess1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	Se tiene un array en que se almacena información tanto proveniente como no
	proveniente de sources, parte de la información que almacena es enviada como
	parámetro del método \textit{sendTextMessage}. \textit{Observación:}
	Para la técnica de análisis de FlowDroid(taint analysis), se marca únicamente el
	índice del array donde se almacena el dato considerado como source, así,
	cuando se envía como parámetro del método \textit{sendTextMessage},
	el dato de un índice no marcado, no se genera leak. Para nuestra técnica
	de análisis(flujo de información mediante JIF), para que un array almacene
	información con nivel de seguridad alto, primero debe ser catalogo(anotado)
	con nivel de seguridad alto, lo que implica que el array podrá almacenar
	información tanto de nivel de seguridad alto como bajo, pero toda la
	información quedará con nivel de seguridad alto. En consecuencia, al enviar
	cualquier índice del array como parámetro del método 
	\textit{sendTextMessage} se presenta un flujo de información no
	permitido. & 0
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Exceptions2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. El control de flujo del
	programa conduce de manera implícita a la captura de una excepción tipo
	RuntimeException, desde allí se utiliza información proveída por la variable
	\textit{imei}, como parámetro para invocar el método \textit{sendTextMessage}.
	Generando un flujo de información indebido. & 1
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ImplicitFlows\_ImplicitFlow2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 La variable \textit{userInputPassword} con nivel de seguridad alto, almacena
	 información de un campo EditText tipo textPassword(password suministrado por
	 el usuario). Se generan flujos de información indebidos: al tratar de asignar
	 información a la variable passwordCorrect con nivel de seguridad bajo, a
	 partir de la comparación de información con nivel de seguridad alto(variable
	 textPassword), después, al tratar de mostrar en el \textit{log} información
	 que depende de tal comparación. & 1\\
	\hline
	
\end{tabular}
\end{table}

Cada aplicación del conjunto de prueba es analizada con FlowDroid y con el
Prototipo, los resultados obtenidos son presentados en la
tabla\ref{tb:resultados}. En esta, por cada caso de prueba se indica la cantidad
de leaks que presenta, el resultado y el tiempo que tarda el análisis para
ambas herramientas.
Los resultados del análisis son calificados como: Falso Positivo(FP) cuando se
detecta un leak que no existe; Falso Negativo(FN) cuando no se detecta un leak
existente; Verdadero Positivo(TP) cuando se detecta un leak existente; Verdadero
Negativo(TN) cuando no existe leak que detectar.\newline 
El tiempo que tarda cada herramienta para evaluar el respectivo testcase es
medido con el comando \textit{time}.
 
\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Resultados de evaluación. Donde
\textit{Testcase} especifica el nombre de la aplicación que se está evaluando;
\textit{Leaks} indica si el testcase presenta fugas de información;
\textit{FlowDroid} y  \textit{Prototipo} muetran los resultados devueltos por
cada herramienta; \textit{tF} y \textit{tF}, señalan el tiempo que toma el
análisis para Flowdroid y para el Prototipo, respectivamente.}
\label{tb:resultados}
\begin{tabular}{|p{5.8cm}|p{1cm}|p{2.1cm}|p{2.1cm}|p{1cm}|p{1cm}|}
	\hline
	\textbf{Testcase} & \textbf{Leaks} & \textbf{FlowDroid} &
	\textbf{Prototipo} & \textbf{ tF} & 
	\textbf{tP}\\
	\hline
	AndroidSpecific\_DirectLeak1 & 1 & TP & TP &5.371s &2.063s\\
	\hline
	AndroidSpecific\_InactiveActivity & 0 & TN & FP  &3.255s &2.469s\\
	\hline
	AndroidSpecific\_LogNoLeak & 0 & TN & TN &5.505s &2.946s\\
	\hline
	AndroidSpecific\_Obfuscation1 & 1 & TP & TP &6.734s &2.706s\\
	\hline
	 AndroidSpecific\_PrivateDataLeak2 & 1 & TP & TP & 6.144s &2.644s\\
	\hline
	 ArraysAndLists\_ArrayAccess1 & 0 & FP & FP & 4.708s & 1.278s\\
	\hline
	 ArraysAndLists\_ArrayAccess2 & 0 & FP & FP & 4.4s &1.361s\\
	 \hline
	 GeneralJava\_Exceptions1 & 1 & TP & TP &6.397s &2.755s\\
	\hline
	 GeneralJava\_Exceptions2 & 1 & TP & TP &5.887s &1.980s\\
	\hline
	GeneralJava\_Exceptions3 & 0 & FP & FP &6.008s &2.032s\\
	\hline
	GeneralJava\_Exceptions4 & 1 & TP & TP &5.731s &2.313s\\
	\hline
	GeneralJava\_Loop1 & 1 & TP & TP &5.605s &2.800s\\
	\hline
	GeneralJava\_Loop2 & 1 & TP & TP &4.719s &1.361s\\
	\hline
	GeneralJava\_UnreachableCode & 0 & TN & FP &3.792s &1.197s\\
	\hline
	ImplicitFlows\_ImplicitFlow1 & 1 & FN & TP &4.853s &1.331s\\
	\hline
	ImplicitFlows\_ImplicitFlow2 & 1 & FN & TP &4.496s &1.212s\\
	\hline
	ImplicitFlows\_ImplicitFlow4 & 1 & FN & TP &4.375s &1.224s\\
	\hline
	Lifecycle\_ActivityLifecycle3 & 1 & TP & TP &4.792s &1.222s\\
	\hline
	Lifecycle\_BroadcastReceiverLifecycle1 & 1 & TP & TP &4.456s &1.061s\\
	\hline
	Lifecycle\_ServiceLifecycle1 & 1 & TP & TP &5.225s &1.180s\\
	\hline
\end{tabular}
\end{table}

-\textit{Resultados de precisión}\newline
En lo que respecta a los resultados del Prototipo, los FP correspondientes a
AndroidSpecific\_InactiveActivity y GeneralJava\_UnreachableCode, surgen como
consecuencia de realizar el análisis asumiendo que el desarrollador utiliza lo
que implementa.\newline 
Por otro lado, en el caso de ArraysAndLists\_ArrayAccess1 y
ArraysAndLists\_ArrayAccess2, no es sencillo calificar los resultados como FP,
puesto que, para lo que está analizando FlowDroid(verificar que su técnica de
análisis diferencie entre los elementos marcados y no marcados de un array),
efectivamente se presentan FP, sin embargo, para la forma en que se deben
implementar los programas en jif, donde se suele definir un nivel de seguridad
para todo el array antes de almacenar los elementos en el mismo, podría decirse
que no se trata de un FP, porque se revelo información que había sido
catalogada con nivel de seguridad alto.\newline 
La detección de flujos implícitos podría ser un elemento diferenciador.\newline
-\textit{Resultados de desempeño}\newline
Se podría destacar como positivo que el análisis de flujo de información
mediante técnicas de tipado de seguridad, requiere menos tiempo que la técnica
de marcado de datos utilizada por FlowDroid.

-\textit{Acerca de por qué FlowDroid no detecta flujos implícitos}\newline
El análisis de FlowDroid utiliza técnicas DataFlow, específicamente, utiliza
tainting análisis. Para hacer seguimiento al flujo de información de un
programa, la técnica de análisis tainting se basa en: asociar una o más marcas
con el valor de los datos en el programa, y en propagarlas. Dependiendo de los
criterios definidos para el análisis, la marca puede ser propagada a causa de
flujos explícitos o de flujos implícitos, o a causa de ambos. En flujos
explícitos la propagación ocurre cuando el valor de una variable marcada está
implicada en el calculo de otra variable. En flujos implícitos la propagación
tiene lugar a través de dependencias en el control de flujo del programa, por
ejemplo, cuando el valor de un dato marcado afecta indirectamente otra varible.\newline 
En el caso de FlowDroid, los criterios que fundamentan el análisis de la
herramienta, hacen que el marcado de datos se propague para flujos explícitos y
y no para flujos implícitos. Por consiguiente, FlowDroid no detecta flujos
implícitos.

%En el caso de TaintDroid, tampoco detecta flujos implícitos, porque entre las
% desiciones de diseño de la herramienta está enfocarse en el seguimeinto al
% flujo de datos y no al flujo de control, puesto que si incluyen seguimiento al
% flujo de control, se adiciona sobrecarga a la herramienta, la cual es de tipo
% dinámico.

\subsubsection{Comparación de resultados}
\begin{table}[H]
\begin{center}
\caption{Comparación de precisión entre FlowDroid y Prototipo}
\label{tb:precision}
\begin{tabular}{cc|c|c}
\cline{2-3}
& \multicolumn{0}{ |c|  }{\multirow{1}{*}{FlowDroid} } & Prototipo \\
\cline{1-3}
\multicolumn{0}{ |c|  }{\multirow{0}{*}{FP} }  & 3 & 5 &  \\ \cline{0-2}
\multicolumn{0}{ |c|  }{\multirow{0}{*}{FN} }  & 3 & 0 &  \\ \cline{0-2}
\multicolumn{0}{ |c|  }{\multirow{0}{*}{TP} }  & 11 & 14 &  \\ \cline{0-2}
\multicolumn{0}{ |c|  }{\multirow{0}{*}{TN} }  & 3 & 1 &  \\ \cline{0-2}
\end{tabular}
\end{center}
\end{table}
En la tabla \ref{tb:precision} se comparan los resultados del análisis.\newline
El conjunto de prueba está conformado por 20 aplicaciones, de las cuales 14
presentan leaks.
Los resultados obtenidos señalan que de las 14 fugas existentes, el Prototipo
las detecta todas, presenta 14 TP(verdaderos positivos); mientras que, FlowDroid
deja pasar 3.\newline
Por otro lado, el Prototipo presenta más falsos positivos que FlowDroid, de los
6 testcases que no presentan leaks, el prototipo identifica 5 como si fuesen
fugas, mientras que FlowDroid identifica 3.

A partir de tales resultados se mide la Precisión y Recall para ambas
herramientas. La precisión \textit{p} mide si la herramienta detecta fugas
cuando efectivamente las hay(no reporta falsos positivos TP), el Recall
\textit{r} mide si la herramienta deja pasar fugas de información( no reporta
falsos negativos FN).
Las formulas para ambas métricas son:
\begin{lstlisting}
Precision p = TP/(TP +FP)
Recall r = TP/(TP+FN) 
\end{lstlisting}
Donde TP representa el total de verdaderos positivos, FP el total de falsos
positivos y  FN el total de falsos negativos.\newline

Con un porcentaje del 78\%, FlowDroid presenta mayor precisión frente al
Prototipo, que presenta un porcentaje del 73\%.\newline
En cuanto a Recall, el Prototipo presenta un porcentaje del 100\%, superando a
flowDroid que presenta un porcentaje del 78\%.




-\textit{Qué tanto cambia la anotación del código original}
- adición de catch.






























