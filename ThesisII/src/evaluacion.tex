\label{ch:evaluacion}
\chapter{Evaluación}
Ventajas y limitaciones de la solución.\newline 
Si aplica, evaluación de desempeño.  \newline 
Si aplica, evaluación de usabilidad.  
Hay otras soluciones similares? \newline 
Cuáles son las diferencias y las ventajas y desventajas con respecto a esas soluciones.

\section{Consideraciones de evaluación}
No se consideran flujos de información vía interAppComunicación. Por ejemplo,
varias aplicaciones que se comunican entre sí.

\section{Evaluación conjunto de aplicaciones}
Para la evaluación del prototipo se toma un grupo de testcases de DroidBech, el
benchmark de FlowDroid, evaluables frente a la política de seguridad
establecida.\newline 
Se considera con nivel de seguridad alto, variables y métodos que almacenan y
modifican(respectivamente), información considerada como privada(Sources).\newline 
Se considera con nivel de seguridad bajo, canales para envío de mensajes,
muestra de logs y canales creados durante el control de flujo del
programa.\newline

En la tabla \ref{tb:muestra-descripApps} se describen algunos de los testcases a
evaluar, la descripción completa de los casos de prueba, se encuentra
en los anexos\ref{sc:testcases}.

En los casos en que se requiere, se precisan observaciones entre los resultados
de evaluación esperados para la técnica de análisis utilizada por FlowDroid y la técnica de análisis
propuesta en el presente trabajo.\newline


\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Descripción aplicaciones de prueba}
\label{tb:muestra-descripApps}
\begin{tabular}{|p{13cm}|p{1cm}|}
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_DirectLeak1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{mrg} tiene un nivel de seguridad alto,
	almacena información retornada por el método source \textit{getDeviceId}. Se
	genera flujo de información directo entre información con nivel de seguridad alto e
	información con nivel de seguridad bajo, al enviar como parámetro del método
	\textit{sendTextMessage}, información de la variable \textit{mrg}. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_LogNoLeak}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	El caso de prueba no presenta información con niveles de seguridad alto. Se
	presentan flujos de información entre información con el mismo nivel de
	seguridad, en este caso bajo, lo cual es permitido. & 0 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ArraysAndLists\_ArrayAccess1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	Se tiene un array en que se almacena información tanto proveniente como no
	proveniente de sources, parte de la información que almacena es enviada como
	parámetro del método \textit{sendTextMessage}. \textit{Observación:}
	Para la técnica de análisis de FlowDroid(taint analysis), se marca únicamente el
	índice del array donde se almacena el dato considerado como source, así,
	cuando se envía como parámetro del método \textit{sendTextMessage},
	el dato de un índice no marcado, no se genera leak. Para nuestra técnica
	de análisis(flujo de información mediante JIF), para que un array almacene
	información con nivel de seguridad alto, primero debe ser catalogo(anotado)
	con nivel de seguridad alto, lo que implica que el array podrá almacenar
	información tanto de nivel de seguridad alto como bajo, pero toda la
	información quedará con nivel de seguridad alto. En consecuencia, al enviar
	cualquier índice del array como parámetro del método 
	\textit{sendTextMessage} se presenta un flujo de información no
	permitido. & 0
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Exceptions2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. El control de flujo del
	programa conduce de manera implícita a la captura de una excepción tipo
	RuntimeException, desde allí se utiliza información proveída por la variable
	\textit{imei}, como parámetro para invocar el método \textit{sendTextMessage}.
	Generando un flujo de información indebido. & 1
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ImplicitFlows\_ImplicitFlow2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 La variable \textit{userInputPassword} con nivel de seguridad alto, almacena
	 información de un campo EditText tipo textPassword(password suministrado por
	 el usuario). Se generan flujos de información indebidos: al tratar de asignar
	 información a la variable passwordCorrect con nivel de seguridad bajo, a
	 partir de la comparación de información con nivel de seguridad alto(variable
	 textPassword), después, al tratar de mostrar en el \textit{log} información
	 que depende de tal comparación. & 1\\
	\hline
	
\end{tabular}
\end{table}



La tabla\ref{tb:comparacion} presenta los resultados de analizar los casos de
prueba previamente descritos, tanto con FlowDroid como con el prototipo. Los
resultados se califican como: Falso Positivo(FP) cuando se detecta un leak que
no existe; Falso Negativo(FN) cuando no se detecta un leak existente; Verdadero
Positivo(TP) cuando se detecta un leak existente; Verdadero Negativo(TN) cuando
no existe leak que detectar.\newline 
El tiempo que tarda cada herramienta para evaluar el respectivo testcase es
medido con el comando \textit{time}.
 
\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Comparación Precisión entre FlowDroid y Prototipo. Los campos tF y tP,
describen el tiempo que tarda Flowdroid y el Prototipo(respectivamente) en
realizar el análisis para casos de prueba, evaluados. }
\label{tb:comparacion}
\begin{tabular}{|p{5.8cm}|p{1cm}|p{2.1cm}|p{2.1cm}|p{1cm}|p{1cm}|}
	\hline
	\textbf{Testcase} & \textbf{Leaks} & \textbf{FlowDroid} &
	\textbf{Prototipo} & \textbf{ t F} & 
	\textbf{t P}\\
	\hline
	AndroidSpecific\_DirectLeak1 & 1 & TP & TP &5.371s &2.063s\\
	\hline
	AndroidSpecific\_InactiveActivity & 0 & TN & FP  &3.255s &2.469s\\
	\hline
	AndroidSpecific\_LogNoLeak & 0 & TN & TN &5.505s &2.946s\\
	\hline
	AndroidSpecific\_Obfuscation1 & 1 & TP & TP &6.734s &2.706s\\
	\hline
	 AndroidSpecific\_PrivateDataLeak2 & 1 & TP & TP & 6.144s &2.644s\\
	\hline
	 ArraysAndLists\_ArrayAccess1 & 0 & FP & FP & 4.708s & 1.278s\\
	\hline
	 ArraysAndLists\_ArrayAccess2 & 0 & FP & FP & 4.4s &1.361s\\
	 \hline
	 GeneralJava\_Exceptions1 & 1 & TP & TP &6.397s &2.755s\\
	\hline
	 GeneralJava\_Exceptions2 & 1 & TP & TP &5.887s &1.980s\\
	\hline
	GeneralJava\_Exceptions3 & 0 & FP & FP &6.008s &2.032s\\
	\hline
	GeneralJava\_Exceptions4 & 1 & TP & TP &5.731s &2.313s\\
	\hline
	GeneralJava\_Loop1 & 1 & TP & TP &5.605s &2.800s\\
	\hline
	GeneralJava\_Loop2 & 1 & TP & TP &4.719s &1.361s\\
	\hline
	GeneralJava\_UnreachableCode & 0 & TP & FP &3.792s &1.197s\\
	\hline
	ImplicitFlows\_ImplicitFlow1 & 1 & FN & TP &4.853s &1.331s\\
	\hline
	ImplicitFlows\_ImplicitFlow2 & 1 & FN & TP &4.496s &1.212s\\
	\hline
	ImplicitFlows\_ImplicitFlow4 & 1 & FN & TP &4.375s &1.224s\\
	\hline
	Lifecycle\_ActivityLifecycle3 & 1 & TP & TP &4.792s &1.222s\\
	\hline
	Lifecycle\_BroadcastReceiverLifecycle1 & 1 & TP & TP &4.456s &1.061s\\
	\hline
	Lifecycle\_ServiceLifecycle1 & 1 & TP & TP &5.225s &1.180s\\
	\hline
\end{tabular}
\end{table}

-\textit{Resultados de precisión}\newline
En lo que respecta a los resultados del Prototipo, los FP correspondientes a
AndroidSpecific\_InactiveActivity y GeneralJava\_UnreachableCode, surgen como
consecuencia de realizar el análisis asumiendo que el desarrollador utiliza lo
que implementa.\newline 
Por otro lado, en el caso de ArraysAndLists\_ArrayAccess1 y
ArraysAndLists\_ArrayAccess2, no es sencillo calificar los resultados como FP,
puesto que, para lo que está analizando FlowDroid(verificar que su técnica de
análisis diferencie entre los elementos marcados y no marcados de un array),
efectivamente se presentan FP, sin embargo, para la forma en que se deben
implementar los programas en jif, donde se suele definir un nivel de seguridad
para todo el array antes de almacenar los elementos en el mismo, podría decirse
que no se trata de un FP, porque se revelo información que había sido
catalogada con nivel de seguridad alto.\newline 
La detección de flujos implícitos podría ser un elemento diferenciador.\newline
-\textit{Resultados de desempeño}\newline
Se podría destacar como positivo que el análisis de flujo de información
mediante técnicas de tipado de seguridad, requiere menos tiempo que la técnica
de marcado de datos utilizada por FlowDroid.

-\textit{Acerca de por qué FlowDroid no detecta flujos implícitos}\newline
El análisis de FlowDroid utiliza técnicas DataFlow, específicamente, utiliza
tainting análisis. Para hacer seguimiento al flujo de información de un
programa, la técnica de análisis tainting se basa en: asociar una o más marcas
con el valor de los datos en el programa, y en propagarlas. Dependiendo de los
criterios definidos para el análisis, la marca puede ser propagada a causa de
flujos explícitos o de flujos implícitos, o a causa de ambos. En flujos
explícitos la propagación ocurre cuando el valor de una variable marcada está
implicada en el calculo de otra variable. En flujos implícitos la propagación
tiene lugar a través de dependencias en el control de flujo del programa, por
ejemplo, cuando el valor de un dato marcado afecta indirectamente otra varible.\newline 
En el caso de FlowDroid, los criterios que fundamentan el análisis de la
herramienta, hacen que el marcado de datos se propague para flujos explícitos y
y no para flujos implícitos. Por consiguiente, FlowDroid no detecta flujos
implícitos.

%En el caso de TaintDroid, tampoco detecta flujos implícitos, porque entre las
% desiciones de diseño de la herramienta está enfocarse en el seguimeinto al
% flujo de datos y no al flujo de control, puesto que si incluyen seguimiento al
% flujo de control, se adiciona sobrecarga a la herramienta, la cual es de tipo
% dinámico.

-\textit{Qué tanto cambia la anotación del código original}
- adición de catch.






























