\label{ch:evaluacion}
\chapter{Evaluación}
Ventajas y limitaciones de la solución.\newline 
Si aplica, evaluación de desempeño.  \newline 
Si aplica, evaluación de usabilidad.  
Hay otras soluciones similares? \newline 
Cuáles son las diferencias y las ventajas y desventajas con respecto a esas soluciones.

\section{Consideraciones de evaluación}
No se consideran flujos de información vía interAppComunicación. Por ejemplo,
varias aplicaciones que se comunican entre sí.

\section{Evaluación conjunto de aplicaciones}
Para la evaluación del prototipo se toma un grupo de testcases de DroidBech, el
benchmark de FlowDroid, aplicables para la evaluación de la política de
seguridad establecida.\newline 
Se considera con nivel de seguridad alto, variables y métodos que almacenan y
modifican(respectivamente), información considerada como privada(Sources).\newline 
Se considera con nivel de seguridad bajo, canales para envío de mensajes,
muestra de logs y canales creados durante el flujo del programa.\newline
A continuación se describen los testcases a evaluar, en los casos en que se
requiere, se precisan observaciones entre los resultados de evaluación esperados
para la técnica de análisis utilizada por FlowDroid y la técnica de análisis
propuesta en el presente trabajo.\newline
% \textbf{AndroidSpecific\_DirectLeak1}\newline
% La variable \textit{mrg} tiene un nivel de seguridad alto, almacena
% información retornada por el método source \textit{getDeviceId}. Se genera
% flujo de información directo entre información con nivel de seguridad alto e
% información con nivel de seguridad bajo, al enviar como parámetro del método
% \textit{\textbf{sendTextMessage}}, información de la variable \textit{\textbf{mrg}}.

\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Descripción aplicaciones de prueba}
\label{tb:descripApps}
\begin{tabular}{|p{13cm}|p{1cm}|}
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_DirectLeak1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{mrg} tiene un nivel de seguridad alto,
	almacena información retornada por el método source \textit{getDeviceId}. Se
	genera flujo de información directo entre información con nivel de seguridad alto e
	información con nivel de seguridad bajo, al enviar como parámetro del método
	\textit{sendTextMessage}, información de la variable \textit{mrg}. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_InactiveActivity}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline 
	La variable \textit{imei} tiene un nivel de seguridad alto, almacena
	información retornada por el source getDeviceId. La variable es enviada como
	parámetro a \textit{Log}, canal que muestra información con nivel de
	seguridad bajo. \textit{Observación:} debido a que la actividad en que se
	presenta este flujo de información no está activada en el Manifest de la
	aplicación, para la técnica de análisis de FlowDroid no existen leaks. Para
	nuestra propuesta de análisis si existe leak, porque se asume que los métodos y
	sus aplicaciones podrán ser ejecutados. & 0
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_LogNoLeak}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	El caso de prueba no presenta información con niveles de seguridad alto. Se
	presentan flujos de información entre información con el mismo nivel de
	seguridad, en este caso bajo, lo cual es permitido. & 0 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_Obfuscation1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline 
	La variable \textit{\textbf{mrg}} tiene un nivel de seguridad alto,
	almacena información retornada por el método source getDeviceId().
	Se genera flujo de información entre información con nivel de seguridad alto e
	información con nivel de seguridad bajo, al enviar como parámetro del método
	\textit{sendTextMessage}, información de la variable
	\textit{mrg}. \textit{Observación:} el elemento adicional para este
	testcase es proveer una suplantación de la clase
	android.telephony.TelephonyManager, en el apk de la aplicación. Para la
	evaluación que proponemos, se verifica acorde a la versión que se tiene anotada
	para esta clase, es decir, independientemente de la ofuscación de la clase,
	nuestro análisis debe detectar que existe un flujo de información indebido. &
	1\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{AndroidSpecific\_PrivateDataLeak2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{info} tiene un nivel de seguridad alto, almacena
	información suministrada por el campo EditText de tipo textPassword. Se genera
	flujo de información entre información con nivel de seguridad alto e
	información con nivel de seguridad bajo, al pasar la variable
	\textit{info} como parámetro de \textit{Log}, que muestra
	información con nivel de seguridad bajo. & 1 
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ArraysAndLists\_ArrayAccess1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	Se tiene un array en que se almacena información tanto proveniente como no
	proveniente de sources, parte de la información que almacena es enviada como
	parámetro del método \textit{sendTextMessage}. \textit{Observación:}
	Para la técnica de análisis de FlowDroid(taint analysis), se marca únicamente el
	índice del array donde se almacena el dato considerado como source, así,
	cuando se envía como parámetro del método \textit{sendTextMessage},
	el dato de un índice no marcado, no se genera leak. Para nuestra técnica
	de análisis(flujo de información mediante JIF), para que un array almacene
	información con nivel de seguridad alto, primero debe ser catalogo(anotado)
	con nivel de seguridad alto, lo que implica que el array podrá almacenar
	información tanto de nivel de seguridad alto como bajo, pero toda la
	información quedará con nivel de seguridad alto. En consecuencia, al enviar
	cualquier índice del array como parámetro del método 
	\textit{sendTextMessage} se presenta un flujo de información no
	permitido. & 0
	\\
	\hline
\end{tabular}
\end{table}

\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Descripción aplicaciones de prueba}
\label{tb:descripApps}
\begin{tabular}{|p{13cm}|p{1cm}|}
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ArraysAndLists\_ArrayAccess2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	Se presenta el contexto descrito en ArraysAndLists\_ArrayAccess1, con un
	elemento adicional, se implementa el método calculateIndex(), que calcula el
	índice del array a ser enviado como parámetro del método
	\textit{sendTextMessage}. & 0 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Exceptions1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. Se genera flujo de información
	entre información de nivel de seguridad alto e información con nivel de
	seguridad bajo, al enviar como parámetro del método \textit{sendTextMessage}
	información de la variable \textit{imei}. Este flujo de información se presenta
	dentro de la captura de una excepción RuntimeException(no es verificada
	en tiempo de compilación).
	& 1
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Exceptions2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. El control de flujo del
	programa conduce de manera implícita a la captura de una excepción tipo
	RuntimeException, desde allí se utiliza información proveída por la variable
	\textit{imei}, como parámetro para invocar el método \textit{sendTextMessage}.
	Generando un flujo de información indebido. & 1
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Exceptions3}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. La información proveída por
	\textit{imei} es utilizada como parámetro para invocar el método
	\textit{sendTextMessage} dentro de la captura de una excepción tipo
	RuntimeException, sin embargo, el programa no genera un caso que haga ejecutar
	la captura de la excepción. & 0
	\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Exceptions4}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. información proveída por esta
	variable es enviada como parámetro para la captura de una excepción en tiempo
	de ejecución, donde es utilizado como parámetro para invocar el método
	\textit{sendTextMessage}, generando un flujo de información indebido. & 1\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Loop1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. Se generan flujos de información
	indebidos, primero al tratar de asignar la información de la variable a un
	array con nivel de seguridad bajo(donde se intenta ofuscar la información),
	luego al tratar de enviar la información ofuscada como parámetro del método
	\textit{sendTextMessage}, con nivel de seguridad bajo. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_Loop2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{imei} es de nivel de seguridad alto, almacena información
	devuelta por el método \textit{getDeviceId}. Se busca ofuscar la información de
	\textit{imei} mediante ciclos for anidados, allí se asigna la información de la
	variable a un array con nivel de seguridad bajo. Luego se envía la información
	ofuscada, como parámetro del método \textit{sendTextMessage}, con nivel de
	seguridad bajo, generando otro flujo de información indebido. & 1\\
	\hline
\end{tabular}
\end{table}

\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Descripción aplicaciones de prueba}
\label{tb:descripApps}
\begin{tabular}{|p{13cm}|p{1cm}|}
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{GeneralJava\_UnreachableCode}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{deviceid} con nivel de seguridad alto, está contenida en un
	método que no es llamado, dentro del mismo, \textit{deviceid} es pasada como
	parámetro para invocar el método \textit{sendTextMessage}, cuyo nivel de
	seguridad es bajo. \textit{Observaciones:} para el análisis de FlowDroid el
	programa no presenta leaks, ya que el método nunca es llamado.
	Para nuestro análisis, el programa presenta leak porque se asume que todos los
	métodos son llamados. & 0\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ImplicitFlows\_ImplicitFlow1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 La variable \textit{imei} con nivel de seguridad alto, almacena información
	 devuelta por el método \textit{getDeviceId}, \textit{imei} se pasa como
	 parámetro al método obfuscateIMEI que devuelve la información ofuscada.
	 Después se invoca el método WriteToLog, con la información ofuscada como
	 parámetro para ser mostrada en el log. Al invocar el método WriteToLog con la
	 información ofuscada, se genera un flujo de información indebido. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ImplicitFlows\_ImplicitFlow2}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 La variable \textit{userInputPassword} con nivel de seguridad alto, almacena
	 información de un campo EditText tipo textPassword(password suministrado por
	 el usuario). Se generan flujos de información indebidos: al tratar de asignar
	 información a la variable passwordCorrect con nivel de seguridad bajo, a
	 partir de la comparación de información con nivel de seguridad alto(variable
	 textPassword), después, al tratar de mostrar en el \textit{log} información
	 que depende de tal comparación. & 1\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{ImplicitFlows\_ImplicitFlow4}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	La variable \textit{password} con nivel de seguridad alto, almacena información
	de un campo EditText tipo textPassword, \textit{password} es utilizada como
	parte de los parámetros para invocar el método \textit{lookup} que busca
	identificar el password suministrado por el usuario. Se genera un flujo de
	información indebido, cuando se compara lo retornado por el método para mostrar
	en el \textit{log} información del password. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{Lifecycle\_ActivityLifecycle3}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 El flujo de información entre información con nivel de seguridad alto e
	 información con nivel de seguridad bajo, tiene lugar a través de dos
	 métodos del ciclo de vida de la actividad: onSaveInstanceState y
	 onRestoreInstanceState. En onSaveInstanceState, se asigna información con
	 nivel de seguridad alto a la variable \textit{s}, la información que almacene
	 este método es utilizada durante la reanudación de la actividad, a través del
	 método onRestoreInstanceState, donde se muestra en el \textit{log} información
	 de la variable \textit{s}. & 1\\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{Lifecycle\_BroadcastReceiverLifecycle1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 Se tiene un broadcast receiver  que muestra información con nivel de
	 seguridad alto, contenida en la variable \textit{imei}(almacena información retornada por el
	 método \textit{getDeviceId}) a través del \textit{log}. & 1 \\
	\hline
	\multicolumn{2}{|>{\columncolor[gray]{0.8}}c|}{\textbf{Lifecycle\_ServiceLifecycle1}}\\
	\hline
	\textbf{Descripción} & \textbf{Leaks}\\
	\hline
	 Se tiene un servicio que presenta flujo de información indebida mediante dos
	 métodos de su ciclo de vida. En el método que inicia el servicio
	 onStartCommand, la variable con nivel de seguridad alto, almacena
	 información devuelta por el método \textit{getDeviceId}. Luego el método
	 onLowMemory, se envía información de la variable \textit{secret} a través de
	 un mensaje msm. & 1\\
	\hline
\end{tabular}
\end{table}

La tabla\ref{tb:comparacion} presenta los resultados de analizar los casos de
prueba previamente descritos, tanto con FlowDroid como con el prototipo. Los
resultados se califican como: Falso Positivo(FP) cuando se detecta un leak que
no existe; Falso Negativo(FN) cuando no se detecta un leak existente; Verdadero
Positivo(TP) cuando se detecta un leak existente; Verdadero Negativo(TN) cuando
no existe leak que detectar.\newline 
El tiempo que tarda cada herramienta para evaluar el respectivo testcase es
medido con el comando \textit{time}.
 
\begin{table}[H]
\small\addtolength{\tabcolsep}{-3pt}
\caption{Comparación Precisión entre FlowDroid y Prototipo. Los campos tF y tP,
describen el tiempo que tarda Flowdroid y el Prototipo(respectivamente) en
realizar el análisis para casos de prueba, evaluados. }
\label{tb:comparacion}
\begin{tabular}{|p{5.8cm}|p{1cm}|p{2.1cm}|p{2.1cm}|p{1cm}|p{1cm}|}
	\hline
	\textbf{Testcase} & \textbf{Leaks} & \textbf{FlowDroid} &
	\textbf{Prototipo} & \textbf{ t F} & 
	\textbf{t P}\\
	\hline
	AndroidSpecific\_DirectLeak1 & 1 & TP & TP &5.371s &2.063s\\
	\hline
	AndroidSpecific\_InactiveActivity & 0 & TN & FP  &3.255s &2.469s\\
	\hline
	AndroidSpecific\_LogNoLeak & 0 & TN & TN &5.505s &2.946s\\
	\hline
	AndroidSpecific\_Obfuscation1 & 1 & TP & TP &6.734s &2.706s\\
	\hline
	 AndroidSpecific\_PrivateDataLeak2 & 1 & TP & TP & 6.144s &2.644s\\
	\hline
	 ArraysAndLists\_ArrayAccess1 & 0 & FP & FP & 4.708s & 1.278s\\
	\hline
	 ArraysAndLists\_ArrayAccess2 & 0 & FP & FP & 4.4s &1.361s\\
	 \hline
	 GeneralJava\_Exceptions1 & 1 & TP & TP &6.397s &2.755s\\
	\hline
	 GeneralJava\_Exceptions2 & 1 & TP & TP &5.887s &1.980s\\
	\hline
	GeneralJava\_Exceptions3 & 0 & FP & FP &6.008s &2.032s\\
	\hline
	GeneralJava\_Exceptions4 & 1 & TP & TP &5.731s &2.313s\\
	\hline
	GeneralJava\_Loop1 & 1 & TP & TP &5.605s &2.800s\\
	\hline
	GeneralJava\_Loop2 & 1 & TP & TP &4.719s &1.361s\\
	\hline
	GeneralJava\_UnreachableCode & 0 & TP & FP &3.792s &1.197s\\
	\hline
	ImplicitFlows\_ImplicitFlow1 & 1 & FN & TP &4.853s &1.331s\\
	\hline
	ImplicitFlows\_ImplicitFlow2 & 1 & FN & TP &4.496s &1.212s\\
	\hline
	ImplicitFlows\_ImplicitFlow4 & 1 & FN & TP &4.375s &1.224s\\
	\hline
	Lifecycle\_ActivityLifecycle3 & 1 & TP & TP &4.792s &1.222s\\
	\hline
	Lifecycle\_BroadcastReceiverLifecycle1 & 1 & TP & TP &4.456s &1.061s\\
	\hline
	Lifecycle\_ServiceLifecycle1 & 1 & TP & TP &5.225s &1.180s\\
	\hline
\end{tabular}
\end{table}

-\textit{Resultados de precisión}\newline
En lo que respecta a los resultados del Prototipo, los FP correspondientes a
AndroidSpecific\_InactiveActivity y GeneralJava\_UnreachableCode, surgen como
consecuencia de realizar el análisis asumiendo que el desarrollador utiliza lo
que implementa.\newline 
Por otro lado, en el caso de ArraysAndLists\_ArrayAccess1 y
ArraysAndLists\_ArrayAccess2, no es sencillo calificar los resultados como FP,
puesto que, para lo que está analizando FlowDroid(verificar que su técnica de
análisis diferencie entre los elementos marcados y no marcados de un array),
efectivamente se presentan FP, sin embargo, para la forma en que se deben
implementar los programas en jif, donde se suele definir un nivel de seguridad
para todo el array antes de almacenar los elementos en el mismo, podría decirse
que no se trata de un FP, porque se revelo información que había sido
catalogada con nivel de seguridad alto.\newline 
La detección de flujos implícitos podría ser un elemento diferenciador.\newline
-\textit{Resultados de desempeño}\newline
Se podría destacar como positivo que el análisis de flujo de información
mediante técnicas de tipado de seguridad, requiere menos tiempo que la técnica
de marcado de datos utilizada por FlowDroid.

-\textit{Acerca de por qué FlowDroid no detecta flujos implícitos}\newline
El análisis de FlowDroid utiliza técnicas DataFlow, específicamente, utiliza
tainting análisis. Dependiendo de los criterios para propagar la marca entre los
datos, el análisis mediante tainting puede enfocarse en el marcado de flujo de
datos o en el marcado de control de flujo, o en ambos. En el caso de FlowDroid
el análisis se concentra en el marcado de flujo de datos, esto significa que la
herramienta está en capacidad de detectar flujos explicitos, pero no flujos
implicítos generados a través del flujo de control del programa.
































