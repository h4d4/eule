\label{ch:anexos}
\chapter{Anexos}
\section{Instrucciones para uso del prototipo}
Se cuenta con un ambiente de prueba, tanto para generar la versión JIF del
testcase a evaluar mediante el generador de labels, como para evaluarlos con el
compilador de JIF, ese ambiente esta alojado en el directorio:
\textbf{\small{\ttfamily{/home/estudiante/eule}}}, de allí intersan los
subdirectorios \textbf{\small{\ttfamily{androidFlows}}},
\textbf{\small{\ttfamily{InputLabelGenerator}}} y el jar
\textbf{\small{\ttfamily{LabelGenerator.jar}}}.

El subdirectorio \textbf{\small{\ttfamily{androidFlows}}} contiene la estructura
de archivos necesaria para ejecutar JIF, donde:
\textbf{\small{\ttfamily{sig-src}}} aloja clases java y clases de la API de
android, anotadas para que JIF las reconozca de forma nativa.\newline
\textbf{\small{\ttfamily{jif-src/test}}} están clases de la API de Android que
han sido anotadas de forma no nativa(Activity.jif, BroadcastReceiver.jif,
Log.jif, R.jif, Service.jif, SmsManager.jif). Allí se deben alojar las clases
jif a ejecutar.\newline
En {\small{\ttfamily{InputLabelGenerator}}} están los fuentes java que se pasan
como entrada para el genenrador de labels, que devuleve la versión JIF de los
mismos.\newline
Instrucciones de ejecución:\newline
(1) Ejecutar el jar para la generación de los labels:
\begin{lstlisting}
estudiante@debianJessie:~/eule$ java -jar LabelGenerator.jar
\end{lstlisting}
Una vez se ejecuta el .jar, se solicita el directorio de entrada(que contiene
las aplicacione a anotar) y el directorio de salida(para alojar las
aplicaciones anotadas). Separados por el simbolo @
\begin{lstlisting}
Ingrese la ruta completa para el directorio de entrada, y para el 
directorio de salida:
Ejemplo: dir-entrada@dir-salida 
\end{lstlisting}
Se deben pasar los directorios:
\begin{lstlisting}
InputLabelGenerator@androidFlows/jif-src/test
\end{lstlisting}

(2) Ejecutar el .jif generado:\newline
En la ruta que se paso como directorio de salida en el punto
anterior {\small{\ttfamily{androidFlows/jif-src/test}}}, se genera un
subdirectorio por cada aplicación, cada uno con un .java y un *-out.jif.
Se debe ejecutar el *-out.jif, los pasos para ello son:\newline
(2a) ejecutar el script setup.sh
\begin{lstlisting}
estudiante@debianJessie:~/eule/androidFlows$ ./setup.sh
\end{lstlisting}
(2b) ejecutar el caso de prueba a evaluar, por ejemplo, para
evaluar el testcase ArraysAndLists\_ArrayAccess1, se debe ejecutar:
\begin{lstlisting}
estudiante@debianJessie:~/eule/androidFlows$ ./jifc-java-libraries.sh \
jif-src/test/ArraysAndLists_ArrayAccess1/ArrayAccess1-out.jif
\end{lstlisting}
Cuando se presentan flujos indebidos, el compilador genera una salida señalando
los problemas de seguridad.
\lstset{
    language=bash,
    basicstyle=\tiny,
  }
\begin{lstlisting}
estudiante@debianJessie:~/eule/androidFlows$ ./jifc-java-libraries.sh \
jif-src/test/ArraysAndLists_ArrayAccess1/ArrayAccess1-out.jif 
/home/estudiante/eule/androidFlows/jif-src/test/ArraysAndLists_ArrayAccess1/ArrayAccess1-out.jif:51: 
    Unsatisfiable constraint
    	general constraint:
    		actual_arg_3 <= formal_arg_3
    	in this context:
    		{Alice->; _<-_ ⊔ caller_pc} <= {}
    	cannot satisfy equation:
    		{Alice->} ⊑ {}
    	in environment:
    		{this} ⊑ {caller_pc}
    		[]

    Label Descriptions
    ------------------
     - actual_arg_3 = the label of the 3rd actual argument
     - actual_arg_3 = {Alice->; _<-_ ⊔ caller_pc}
     - formal_arg_3 = the upper bound of the formal argument text
     - formal_arg_3 = {}
     - caller_pc = The pc at the call site of this method (bounded above by 
    {})
     - this = label of the special variable "this" in test.ArrayAccess1

    The label of the actual argument, actual_arg_3, is more restrictive than 
    the label of the formal argument, formal_arg_3.
            sms.sendTextMessage("+49 1234", null, arrayData[2], null, null);
                                                  ^-------^

1 error.
estudiante@debianJessie:~/eule/androidFlows$
\end{lstlisting}

Cuando el caso de prueba no presenta flujos indebidos, el compilador no genera
salidas, por ejemplo, al evaluar el testcase AndroidSpecific\_LogNoLeak, el
compilador retorna el prom de la shell, sin ningún comentario.
